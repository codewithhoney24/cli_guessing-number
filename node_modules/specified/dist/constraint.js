"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Constraint = {
    generic: {
        oneOf: function () {
            var options = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                options[_i] = arguments[_i];
            }
            return {
                version: 1,
                definition: {
                    name: "oneOf",
                    settings: { options: options }
                },
                eval: function (value) {
                    return { err: options.indexOf(value) < 0 ? {
                            code: "constraint.generic.oneOf.unknown_value",
                            value: value,
                            allowed: options,
                            message: "Not one of the accepted options."
                        } : null };
                }
            };
        }
    },
    number: {
        integer: {
            version: 1,
            definition: {
                name: "integer"
            },
            eval: function (value) {
                return { err: value % 1 !== 0 ? {
                        code: "constraint.number.integer",
                        value: value,
                        message: "Not an integer."
                    } : null };
            }
        },
        finite: {
            version: 1,
            definition: {
                name: "finite"
            },
            eval: function (value) {
                return { err: !Number.isFinite(value) ? {
                        code: "constraint.number.finite",
                        value: value,
                        message: "Not a finite number."
                    } : null };
            }
        },
        above: function (lowerLimit) {
            return {
                version: 1,
                definition: {
                    name: "above",
                    settings: { lowerLimit: lowerLimit }
                },
                eval: function (value) {
                    return { err: !(value > lowerLimit) ? {
                            code: "constraint.number.above",
                            value: value,
                            message: "Not above " + lowerLimit + "."
                        } : null };
                }
            };
        },
        below: function (upperLimit) {
            return {
                version: 1,
                definition: {
                    name: "below",
                    settings: { upperLimit: upperLimit }
                },
                eval: function (value) {
                    return { err: !(value < upperLimit) ? {
                            code: "constraint.number.below",
                            value: value,
                            message: "Not below " + upperLimit + "."
                        } : null };
                }
            };
        },
        atLeast: function (lowerLimit) {
            return {
                version: 1,
                definition: {
                    name: "atLeast",
                    settings: { lowerLimit: lowerLimit }
                },
                eval: function (value) {
                    return { err: !(value >= lowerLimit) ? {
                            code: "constraint.number.atLeast",
                            value: value,
                            message: "Less than " + lowerLimit + "."
                        } : null };
                }
            };
        },
        atMost: function (upperLimit) {
            return {
                version: 1,
                definition: {
                    name: "atMost",
                    settings: { upperLimit: upperLimit }
                },
                eval: function (value) {
                    return { err: !(value <= upperLimit) ? {
                            code: "constraint.number.atMost",
                            value: value,
                            message: "Larger than " + upperLimit + "."
                        } : null };
                }
            };
        }
    },
    string: {
        notEmpty: {
            version: 1,
            definition: {
                name: "notEmpty"
            },
            eval: function (value) {
                return { err: value === "" ? {
                        code: "constraint.string.notEmpty",
                        value: value,
                        message: "Empty string."
                    } : null };
            }
        },
        length: function (_a) {
            var min = _a.min, max = _a.max;
            return {
                version: 1,
                definition: {
                    name: "length",
                    settings: { min: min, max: max }
                },
                eval: function (value) {
                    if (typeof min !== "undefined" && value.length < min) {
                        return { err: {
                                code: "constraint.string.length.too_short",
                                value: value,
                                message: "String length less than " + min
                            } };
                    }
                    else if (typeof max !== "undefined" && value.length > max) {
                        return { err: {
                                code: "constraint.string.length.too_long",
                                value: value,
                                message: "String length greater than " + max
                            } };
                    }
                    return { err: null };
                }
            };
        },
        regex: function (re, custom) {
            if (custom === void 0) { custom = { errorMessage: "Regex mismatch.", errorCode: "constraint.string.regex" }; }
            return {
                version: 1,
                definition: {
                    name: "regex",
                    settings: { expression: re.source }
                },
                eval: function (value) {
                    return { err: !re.test(value) ? {
                            code: custom.errorCode,
                            value: value,
                            allowed: re.source,
                            message: custom.errorMessage
                        } : null };
                }
            };
        },
        startsWith: function (prefix) {
            return {
                version: 1,
                definition: {
                    name: "startsWith",
                    settings: { prefix: prefix }
                },
                eval: function (value) {
                    return { err: value.substr(0, prefix.length) !== prefix ? {
                            code: "constraint.string.startsWith",
                            value: value,
                            message: "String does not start with '" + prefix + "'."
                        } : null };
                }
            };
        },
        endsWith: function (suffix) {
            return {
                version: 1,
                definition: {
                    name: "endsWith",
                    settings: { suffix: suffix }
                },
                eval: function (value) {
                    return { err: value.substr(value.length - suffix.length) !== suffix ? {
                            code: "constraint.string.endsWith",
                            value: value,
                            message: "String does not end with '" + suffix + "'."
                        } : null };
                }
            };
        }
    },
    map: {
        size: function (_a) {
            var min = _a.min, max = _a.max;
            return {
                version: 1,
                definition: {
                    name: "size",
                    settings: { min: min, max: max }
                },
                eval: function (value) {
                    var numKeys = Object.keys(value).length;
                    if (typeof min !== "undefined" && numKeys < min) {
                        return { err: {
                                code: "constraint.map.size.too_small",
                                value: value,
                                message: "Object size less than " + min
                            } };
                    }
                    else if (typeof max !== "undefined" && numKeys > max) {
                        return { err: {
                                code: "constraint.map.size.too_large",
                                value: value,
                                message: "Object size greater than " + max
                            } };
                    }
                    return { err: null };
                }
            };
        }
    },
    array: {
        length: function (_a) {
            var min = _a.min, max = _a.max;
            return {
                version: 1,
                definition: {
                    name: "length",
                    settings: { min: min, max: max }
                },
                eval: function (value) {
                    return { err: (typeof min !== "undefined" && value.length < min) ? {
                            code: "constraint.array.length.too_short",
                            value: value,
                            message: "Array length less than " + min
                        } :
                            (typeof max !== "undefined" && value.length > max) ? {
                                code: "constraint.array.length.too_long",
                                value: value,
                                message: "Array length greater than " + max
                            } :
                                null
                    };
                }
            };
        },
        includes: function (includedValue) {
            return {
                version: 1,
                definition: {
                    name: "includes",
                    settings: { value: includedValue }
                },
                eval: function (value) {
                    return { err: value.indexOf(includedValue) < 0 ? {
                            code: "constraint.array.includes",
                            value: value,
                            message: "Value is not included in array."
                        } : null };
                }
            };
        },
        unique: function (equalsFunc) {
            if (equalsFunc === void 0) { equalsFunc = function (a, b) { return a === b; }; }
            return {
                version: 1,
                definition: {
                    name: "unique"
                },
                eval: function (value) {
                    for (var i = 0; i < value.length; i++) {
                        for (var j = i + 1; j < value.length; j++) {
                            if (equalsFunc(value[i], value[j])) {
                                return { err: {
                                        code: "constraint.array.unique",
                                        value: value,
                                        message: "Array has duplicate elements at index " + i + " and " + j + "."
                                    } };
                            }
                        }
                    }
                    return { err: null };
                }
            };
        }
    }
};
