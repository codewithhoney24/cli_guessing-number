import { Spec, EvalResult, ValidationFailure, VerifiedType } from "./spec";
interface OptionalSpec extends Spec<any, any> {
    optional: true;
}
interface NonOptionalSpec extends Spec<any, any> {
    optional?: false;
    defaultValue?: unknown;
}
declare type NonOptionalAttributes<S> = {
    [A in keyof S]: S[A] extends {
        optional: true;
    } ? never : A;
};
declare type OptionalAttributes<S> = {
    [A in keyof S]: S[A] extends {
        optional: true;
    } ? A : never;
};
interface Schema {
    [attr: string]: (OptionalSpec | NonOptionalSpec) & {
        description?: string;
    };
}
declare type SpecType<S> = S extends Spec<EvalResult<any>, any> ? VerifiedType<S> : never;
declare type TupleSpecTypes<T> = {
    [P in keyof T]: SpecType<T[P]>;
};
export declare const Type: {
    unknown: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: null;
            value: unknown;
        };
    };
    null: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                allowed: null;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: null;
        };
    };
    string: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: string;
        };
    };
    number: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: number;
        };
    };
    boolean: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: boolean;
        };
    };
    symbol: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: symbol;
        };
    };
    literal: <D extends {
        [k: string]: true | 1;
    }>(def: D) => {
        version: 1;
        definition: {
            type: string;
            settings: {
                values: string[];
            };
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                allowed: string[];
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: keyof D;
        };
    };
    literalValue: <V extends any[]>(...values: V) => {
        version: 1;
        definition: {
            type: string;
            settings: {
                values: V;
            };
        };
        eval: (value: unknown) => {
            err: null;
            value: V[number];
        } | {
            err: {
                code: string;
                value: unknown;
                allowed: V;
                message: string;
            };
            value?: undefined;
        };
    };
    array: <S extends Spec<any, any>>(spec: S) => {
        version: 1;
        definition: {
            type: string;
            nested: {
                element: import("./spec").SpecDefinition;
            };
        };
        eval: (data: unknown, options: {
            local?: {
                failEarly?: boolean | undefined;
                skipInvalid?: boolean | undefined;
            } | undefined;
            global: {
                failEarly?: boolean | undefined;
            };
        }) => {
            err: {
                code: string;
                value: unknown;
                message: string;
                nestedErrors?: undefined;
            };
            value?: undefined;
        } | {
            err: {
                code: string;
                value: any[];
                message: string;
                nestedErrors: ValidationFailure[];
            };
            value?: undefined;
        } | {
            err: null;
            value: Extract<ReturnType<S["eval"]>, {
                err: null;
            }>["value"][];
        };
    };
    object: <S extends Schema>(schema: S) => {
        version: 1;
        definition: {
            type: "object" | "interface";
            nested: {};
            descriptions: {};
        };
        eval: (data: unknown, options: {
            local?: {
                strict?: boolean | undefined;
                failEarly?: boolean | undefined;
            } | undefined;
            global: {
                failEarly?: boolean | undefined;
            };
        }) => {
            err: {
                code: string;
                value: unknown;
                message: string;
                nestedErrors?: undefined;
            };
            value?: undefined;
        } | {
            err: {
                code: string;
                value: object;
                message: string;
                nestedErrors: ValidationFailure[];
            };
            value?: undefined;
        } | {
            err: null;
            value: { [K in keyof ({ [P in keyof Pick<S, NonOptionalAttributes<S>[keyof S]>]: S[P] extends NonOptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never; } & { [P in keyof Pick<S, OptionalAttributes<S>[keyof S]>]?: (S[P] extends OptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never) | undefined; })]: ({ [P in keyof Pick<S, NonOptionalAttributes<S>[keyof S]>]: S[P] extends NonOptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never; } & { [P in keyof Pick<S, OptionalAttributes<S>[keyof S]>]?: (S[P] extends OptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never) | undefined; })[K]; };
        };
    };
    interface: <S extends Schema>(schema: S) => {
        version: 1;
        definition: {
            type: "object" | "interface";
            nested: {};
            descriptions: {};
        };
        eval: (data: unknown, options: {
            local?: {
                strict?: boolean | undefined;
                failEarly?: boolean | undefined;
            } | undefined;
            global: {
                failEarly?: boolean | undefined;
            };
        }) => {
            err: {
                code: string;
                value: unknown;
                message: string;
                nestedErrors?: undefined;
            };
            value?: undefined;
        } | {
            err: {
                code: string;
                value: object;
                message: string;
                nestedErrors: ValidationFailure[];
            };
            value?: undefined;
        } | {
            err: null;
            value: { [K in keyof ({ [P in keyof Pick<S, NonOptionalAttributes<S>[keyof S]>]: S[P] extends NonOptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never; } & { [P in keyof Pick<S, OptionalAttributes<S>[keyof S]>]?: (S[P] extends OptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never) | undefined; })]: ({ [P in keyof Pick<S, NonOptionalAttributes<S>[keyof S]>]: S[P] extends NonOptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never; } & { [P in keyof Pick<S, OptionalAttributes<S>[keyof S]>]?: (S[P] extends OptionalSpec ? Extract<ReturnType<S[P]["eval"]>, {
                err: null;
            }>["value"] : never) | undefined; })[K]; };
        };
    };
    map: <ValueSpec extends Spec<any, any>>(keySpec: Spec<EvalResult<string>, {}>, valueSpec: ValueSpec) => {
        version: 1;
        definition: {
            type: string;
            nested: {
                key: import("./spec").SpecDefinition;
                value: import("./spec").SpecDefinition;
            };
        };
        eval: (data: unknown, options: {
            local?: {
                failEarly?: boolean | undefined;
                skipInvalidKeys?: boolean | undefined;
                skipInvalidValues?: boolean | undefined;
            } | undefined;
            global: {
                failEarly?: boolean | undefined;
            };
        }) => {
            err: {
                code: string;
                value: unknown;
                message: string;
                nestedErrors?: undefined;
            };
            value?: undefined;
        } | {
            err: {
                code: string;
                value: object;
                message: string;
                nestedErrors: ValidationFailure[];
            };
            value?: undefined;
        } | {
            err: null;
            value: {
                [key: string]: Extract<ReturnType<ValueSpec["eval"]>, {
                    err: null;
                }>["value"];
            };
        };
    };
    tuple: <SpecsTuple extends Spec<any, any>[]>(...specs: SpecsTuple) => {
        version: 1;
        definition: {
            type: string;
            nested: {};
        };
        eval: (data: unknown, options: {
            local?: {
                failEarly?: boolean | undefined;
            } | undefined;
            global: {
                failEarly?: boolean | undefined;
            };
        }) => {
            err: {
                code: string;
                value: unknown;
                message: string;
                nestedErrors?: undefined;
            };
            value?: undefined;
        } | {
            err: {
                code: string;
                value: any[];
                message: string;
                nestedErrors: ValidationFailure[];
            };
            value?: undefined;
        } | {
            err: null;
            value: TupleSpecTypes<SpecsTuple>;
        };
    };
    instance: <T>(ctor: new (..._args: unknown[]) => T) => {
        version: 1;
        definition: {
            type: string;
            settings: {
                className: string;
            };
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: T;
        };
    };
    numeric: {
        version: 1;
        definition: {
            type: string;
        };
        eval: (value: unknown) => {
            err: {
                code: string;
                value: unknown;
                message: string;
            };
            value?: undefined;
        } | {
            err: null;
            value: number;
        };
    };
    booleanKey: (keys: {
        truthy: string[];
        falsy?: string[] | undefined;
    }, options?: {
        caseInsensitive?: boolean | undefined;
    } | undefined) => {
        version: 1;
        definition: {
            type: string;
            settings: {
                keys: {
                    truthy: string[];
                    falsy?: string[] | undefined;
                };
                caseInsensitive: boolean | undefined;
            };
        };
        eval: (value: unknown) => {
            err: null;
            value: boolean;
        } | {
            err: {
                code: string;
                value: unknown;
                allowed: string[];
                message: string;
            };
            value?: undefined;
        };
    };
};
export {};
